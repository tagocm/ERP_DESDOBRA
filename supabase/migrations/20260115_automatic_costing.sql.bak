-- Automatic Product Costing System
-- Author: Antigravity
-- Date: 2026-01-15
-- Description: Implements automatic cost calculation for items based on purchases and BOMs

-- =====================================================
-- 1. FUNCTION: Calculate Finished Good Cost
-- =====================================================
CREATE OR REPLACE FUNCTION calculate_finished_good_cost(p_item_id UUID)
RETURNS NUMERIC AS $$
DECLARE
    v_bom_id UUID;
    v_yield_qty NUMERIC;
    v_total_cost NUMERIC := 0;
    v_component RECORD;
BEGIN
    -- Get active BOM for the item
    SELECT id, yield_qty INTO v_bom_id, v_yield_qty
    FROM bom_headers
    WHERE item_id = p_item_id
      AND is_active = true
      AND deleted_at IS NULL
    LIMIT 1;

    IF v_bom_id IS NULL THEN
        RETURN 0; -- No BOM, no cost
    END IF;

    -- Sum up component costs (grouped by component_item_id to handle duplicates)
    FOR v_component IN
        SELECT 
            bl.component_item_id,
            SUM(bl.qty) as total_qty,
            i.avg_cost
        FROM bom_lines bl
        JOIN items i ON i.id = bl.component_item_id
        WHERE bl.bom_id = v_bom_id
        GROUP BY bl.component_item_id, i.avg_cost
    LOOP
        v_total_cost := v_total_cost + (v_component.total_qty * v_component.avg_cost);
    END LOOP;

    -- Return cost per unit (total_cost / yield)
    IF v_yield_qty > 0 THEN
        RETURN v_total_cost / v_yield_qty;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION calculate_finished_good_cost IS 'Calculates the cost of a finished good based on its BOM components';

-- =====================================================
-- 2. FUNCTION: Update Item Cost
-- =====================================================
CREATE OR REPLACE FUNCTION update_item_cost(p_item_id UUID, p_new_cost NUMERIC)
RETURNS VOID AS $$
BEGIN
    UPDATE items
    SET avg_cost = p_new_cost
    WHERE id = p_item_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION update_item_cost IS 'Updates the avg_cost field for an item';

-- =====================================================
-- 3. FUNCTION: Recalculate Dependent Costs (Cascade)
-- =====================================================
CREATE OR REPLACE FUNCTION recalculate_dependent_costs(p_component_id UUID)
RETURNS VOID AS $$
DECLARE
    v_finished_good RECORD;
    v_new_cost NUMERIC;
    v_item_type TEXT;
BEGIN
    -- Check if this component is used in any BOMs
    FOR v_finished_good IN
        SELECT DISTINCT bh.item_id
        FROM bom_headers bh
        JOIN bom_lines bl ON bl.bom_id = bh.id
        WHERE bl.component_item_id = p_component_id
          AND bh.is_active = true
          AND bh.deleted_at IS NULL
    LOOP
        -- Recalculate cost for each finished good
        v_new_cost := calculate_finished_good_cost(v_finished_good.item_id);
        
        PERFORM update_item_cost(v_finished_good.item_id, v_new_cost);
        
        -- Recursively update products that use this finished good as a component
        -- (e.g., if Granola is used in a "Kit de Granolas")
        PERFORM recalculate_dependent_costs(v_finished_good.item_id);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION recalculate_dependent_costs IS 'Recursively recalculates costs for all finished goods that use a component';

-- =====================================================
-- 4. TRIGGER: Update Cost on Purchase Received
-- =====================================================
CREATE OR REPLACE FUNCTION update_cost_on_purchase_received()
RETURNS TRIGGER AS $$
DECLARE
    v_item RECORD;
BEGIN
    -- Only when status changes to 'received'
    IF NEW.status = 'received' AND (OLD.status IS NULL OR OLD.status != 'received') THEN
        -- Update cost for each item in the purchase order
        FOR v_item IN
            SELECT item_id, unit_cost
            FROM purchase_order_items
            WHERE purchase_order_id = NEW.id
              AND unit_cost > 0
        LOOP
            -- Update raw material/packaging cost
            PERFORM update_item_cost(v_item.item_id, v_item.unit_cost);
            
            -- Recalculate dependent finished goods
            PERFORM recalculate_dependent_costs(v_item.item_id);
        END LOOP;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS purchase_order_cost_update ON purchase_orders;

CREATE TRIGGER purchase_order_cost_update
    AFTER UPDATE ON purchase_orders
    FOR EACH ROW
    EXECUTE FUNCTION update_cost_on_purchase_received();

COMMENT ON TRIGGER purchase_order_cost_update ON purchase_orders IS 'Updates item costs when a purchase order is marked as received';

-- =====================================================
-- 5. TRIGGER: Recalculate on BOM Change
-- =====================================================
CREATE OR REPLACE FUNCTION recalculate_cost_on_bom_change()
RETURNS TRIGGER AS $$
DECLARE
    v_item_id UUID;
    v_new_cost NUMERIC;
BEGIN
    -- Get the item_id from the BOM
    IF TG_OP = 'DELETE' THEN
        SELECT item_id INTO v_item_id FROM bom_headers WHERE id = OLD.bom_id;
    ELSE
        SELECT item_id INTO v_item_id FROM bom_headers WHERE id = NEW.bom_id;
    END IF;
    
    IF v_item_id IS NULL THEN
        RETURN COALESCE(NEW, OLD);
    END IF;
    
    -- Recalculate cost
    v_new_cost := calculate_finished_good_cost(v_item_id);
    PERFORM update_item_cost(v_item_id, v_new_cost);
    
    -- Recalculate dependents
    PERFORM recalculate_dependent_costs(v_item_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS bom_lines_cost_update ON bom_lines;

CREATE TRIGGER bom_lines_cost_update
    AFTER INSERT OR UPDATE OR DELETE ON bom_lines
    FOR EACH ROW
    EXECUTE FUNCTION recalculate_cost_on_bom_change();

COMMENT ON TRIGGER bom_lines_cost_update ON bom_lines IS 'Recalculates finished good costs when BOM lines change';

-- =====================================================
-- 6. TRIGGER: Recalculate on BOM Header Activation
-- =====================================================
CREATE OR REPLACE FUNCTION recalculate_cost_on_bom_header_change()
RETURNS TRIGGER AS $$
DECLARE
    v_new_cost NUMERIC;
BEGIN
    -- Recalculate when BOM is activated/deactivated or yield changes
    IF (TG_OP = 'UPDATE' AND (
        NEW.is_active != OLD.is_active OR 
        NEW.yield_qty != OLD.yield_qty OR
        NEW.deleted_at IS DISTINCT FROM OLD.deleted_at
    )) OR TG_OP = 'INSERT' THEN
        v_new_cost := calculate_finished_good_cost(NEW.item_id);
        PERFORM update_item_cost(NEW.item_id, v_new_cost);
        PERFORM recalculate_dependent_costs(NEW.item_id);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS bom_headers_cost_update ON bom_headers;

CREATE TRIGGER bom_headers_cost_update
    AFTER INSERT OR UPDATE ON bom_headers
    FOR EACH ROW
    EXECUTE FUNCTION recalculate_cost_on_bom_header_change();

COMMENT ON TRIGGER bom_headers_cost_update ON bom_headers IS 'Recalculates finished good costs when BOM headers change';
