
-- 1) Drop old permissive policies
DROP POLICY IF EXISTS "Enable read for all users" ON public.companies;
DROP POLICY IF EXISTS "Enable all for devs" ON public.companies;

DROP POLICY IF EXISTS "Enable read for all users" ON public.users;
DROP POLICY IF EXISTS "Enable all for devs" ON public.users;

-- 2) Create basic Authenticated Read-Only policies
-- This allows any logged-in user to read, but blocks anon/write access for now.
CREATE POLICY "Allow select for authenticated" ON public.companies
    FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Allow select for authenticated" ON public.users
    FOR SELECT
    TO authenticated
    USING (true);

-- 3) Tighten Columns (NOT NULL)
ALTER TABLE public.companies ALTER COLUMN created_at SET NOT NULL;
ALTER TABLE public.companies ALTER COLUMN updated_at SET NOT NULL;

ALTER TABLE public.users ALTER COLUMN created_at SET NOT NULL;
ALTER TABLE public.users ALTER COLUMN updated_at SET NOT NULL;
ALTER TABLE public.users ALTER COLUMN is_active SET NOT NULL;

-- 4) Multi-tenant Email Uniqueness
-- Remove global unique constraint on email.
-- Since we don't know the exact constraint name generated by Postgres (often users_email_key),
-- we try to drop the constraint by name if possible, or drop the unique index.
ALTER TABLE public.users DROP CONSTRAINT IF EXISTS users_email_key;
DROP INDEX IF EXISTS users_email_key;

-- Create composite unique index (scoped to company)
CREATE UNIQUE INDEX idx_users_company_email 
    ON public.users(company_id, email);

-- 5) Partial Indexes for Active Records
CREATE INDEX idx_users_company_active 
    ON public.users(company_id) 
    WHERE deleted_at IS NULL;

CREATE INDEX idx_companies_slug_active 
    ON public.companies(slug) 
    WHERE deleted_at IS NULL;
